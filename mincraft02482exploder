local username = username or 'dev'

local DEBUG_MODE = false
local services = setmetatable({}, { __index = function(self, key) return game:GetService(key) end })
local client = services.Players.LocalPlayer;

local http_request = syn and syn.request or http_request

local KickClient, LoadFromGithub do
	function KickClient(reason)
		return client:Kick(reason)
	end

	local function GetUrl(url)
		local response = http_request({ Url = url, Method = 'GET' })

		local success = response.Success;
		local body = response.Body;

		if not success then
			return false, 'Request failed. StatusCode: ' .. response.StatusCode
		end

		return true, body
	end

	function LoadFromGithub(owner, repo, file, branch)
		local url = 'https://raw.githubusercontent.com/' .. owner .. '/' .. repo .. '/' .. (branch or 'main') .. '/' .. file
		local success, body = GetUrl(url)

		if not success then
			return KickClient('Failed to fetch from github. ' .. table.concat({ 'Url:', url, '\n', 'Error:', tostring(body) }))
		end

		local fn, err = loadstring(body, '@' .. url)
		if not fn then
			return KickClient('Failed to load from github. ' .. table.concat({ 'Url:', url, '\n', 'Error:', tostring(err) }))
		end

		local results = { pcall(fn) }
		local success = table.remove(results, 1)

		if not success then
			return KickClient('Failed to execute from github. ' .. table.concat({ 'Url:', url, '\n', 'Error:', tostring(results[1]) }))
		end

		return unpack(results)
	end

	function LoadFromFile(path)
		local closure, err = loadstring(readfile(path), '@' .. path)
		assert(closure, err)
		return closure()
	end
end

if not DEBUG_MODE then
end

local ESP = DEBUG_MODE and LoadFromFile('ESP-lib/ESP.lua') 			or LoadFromGithub('wally-rblx', 'ESP-lib', 'ESP.lua')
local UI  = DEBUG_MODE and LoadFromFile('LinoriaLib/Library.lua') 	or LoadFromGithub('wally-rblx', 'LinoriaLib', 'Library.lua')

local ThemeManager = DEBUG_MODE and LoadFromFile('LinoriaLib/addons/ThemeManager.lua') or LoadFromGithub('wally-rblx', 'LinoriaLib', 'addons/ThemeManager.lua')
local SaveManager  = DEBUG_MODE and LoadFromFile('LinoriaLib/addons/SaveManager.lua')  or LoadFromGithub('wally-rblx', 'LinoriaLib', 'addons/SaveManager.lua')

local broom = DEBUG_MODE and NEON:belkworks'broom'  or LoadFromGithub('Belkworks', 'broom', 'init.lua', 'master')
local show  = DEBUG_MODE and NEON:belkworks'show' 	or LoadFromGithub('Belkworks', 'show',  'init.lua', 'master')

-- Library addons
ThemeManager:SetFolder('misc-projects')
SaveManager:SetFolder('misc-projects/bad-business')

ThemeManager:SetLibrary(UI)
SaveManager:SetLibrary(UI)

SaveManager:IgnoreThemeSettings()

local syn_context_set = syn and syn.set_thread_identity or setthreadidentity
local syn_context_get = syn and syn.get_thread_identity or getthreadidentity

do
	-- fart bypass
	syn.set_thread_identity(2)
	local s, e = pcall(PluginManager)
	syn.set_thread_identity(7)

	hookfunction(PluginManager, function(...)
		error(e)
	end)
end

-- Utilities
local Utilities = {}
do
	Utilities.MarkedJobIds = {}
	Utilities.Random = Random.new()

	local ServerList = services.TeleportService:GetTeleportSetting('BadBusinessServerHop')
	if ServerList then
		Utilities.MarkedJobIds = services.HttpService:JSONDecode(ServerList)
	end

	function Utilities.ServerHop(mode)
		table.insert(Utilities.MarkedJobIds, game.JobId)
		services.TeleportService:SetTeleportSetting('BadBusinessServerHop', services.HttpService:JSONEncode(Utilities.MarkedJobIds))

		local ServerListUrl = 'https://games.roblox.com/v1/games/%s/servers/public?cursor=%s'
		local Cursor = ''

		local ServerList = {}

		local Start = os.clock()
		while true do
			local success, body = pcall(httpget, game, string.format(ServerListUrl, game.PlaceId, Cursor))
			if not success then
				UI:Notify('Failed to fetch server list because: ' .. body .. '.\nRetrying in 2 seconds.')
				wait(2)

				continue
			end

			local success, decoded = pcall(services.HttpService.JSONDecode, services.HttpService, body)
			if not success then
				UI:Notify('Failed to decode server list because: ' .. decoded .. '.\nRetrying in 2 seconds.')
				wait(2)

				continue
			end

			for _, server in next, decoded.data do
				if table.find(Utilities.MarkedJobIds, server.id) then continue end
				if not server.playing then continue end
				if server.playing >= services.Players.MaxPlayers then continue end

				table.insert(ServerList, {
					id = server.id,
					count = server.playing,
				})
			end

			if not decoded.nextPageCursor then
				break
			end

			Cursor = decoded.nextPageCursor
		end

		if not next(ServerList) then
			return UI:Notify('Server hop failed: No servers found!')
		end

		UI:Notify('Hopping to another server...', 3)
		wait(1)

		local server = ServerList[Utilities.Random:NextInteger(1, #ServerList)]
		services.TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id)
	end
end

-- Auto hop
do
	local function OnPlayerKicked(ForceHop)
		local ErrorCode = services.GuiService:GetErrorCode()
		local Message = services.GuiService:GetErrorMessage()

		if ErrorCode == Enum.ConnectionError.DisconnectLuaKick then 	
			task.delay(0.5, function() services.GuiService:ClearError() end)

			if (ForceHop or Toggles.AutoHopKick.Value) then
				UI:Notify('Automatically hopping servers because we got kicked!')
				Utilities.ServerHop()
			else
				UI:Notify('You have been kicked!\nWaiting for user input...', 1e9)
			end
		end
	end

	Utilities.KickCon = services.GuiService.ErrorMessageChanged:Connect(function()
		Utilities.KickCon:Disconnect()
		OnPlayerKicked()

		services.GuiService.ErrorMessageChanged:Connect(function()
			services.GuiService:ClearError()
		end)
	end)

	task.spawn(OnPlayerKicked, true)
end

-- local tsLoader = require(game:GetService("ReplicatedStorage").TS)
local Tortoiseshell = table.foreach(getupvalues(tsLoader), function(key, val)
    if type(val) == 'table' and rawget(val, 'Signed') then
        local mt = getrawmetatable(val)
        local idx = mt and mt.__index
        
        if type(idx) == 'function' then
            local upvs = debug.getupvalues(idx)
            if type(upvs[1]) == 'table' and rawget(upvs[1], 'PhysicsProjectiles') then
                return upvs[1]
            end
        end
    end
end)

local Tortoiseshell = getupvalue(require(services.ReplicatedStorage:WaitForChild('TS')), 2)
game.ScriptContext:SetTimeout(0.1)

-- Character shit
local GetCharacter, GetTeam, GetPlayerFromCharacter, GetTeamColor
do
	function GetCharacter(player)
		return Tortoiseshell.Characters:GetCharacter(player)
	end

	function GetTeam(player)
		return Tortoiseshell.Teams:GetPlayerTeam(player)
	end

	function GetPlayerFromCharacter(character)
		return Tortoiseshell.Characters:GetPlayerFromCharacter(character)
	end

	function GetTeamColor(player)
		local IsTeamMate = ESP:IsTeamMate(player)
		return Tortoiseshell.Teams.Colors[IsTeamMate and 'Friendly' or 'Enemy']
	end

	ESP.Font = 'Monospace'
	ESP.HighlightColor = Color3.new(1, 1, 1)
	ESP.HighlightColorDark = UI:GetDarkerColor(Color3.new(1, 1, 1))

	ESP.Overrides.GetTeam = GetTeam
	ESP.Overrides.GetPlrFromChar = GetPlayerFromCharacter

	ESP.Overrides.IsTeamMate = function(player)
		return Tortoiseshell.Teams:ArePlayersFriendly(player, client)
	end

	ESP.Overrides.GetColor = function(character)
	    local player = ESP:GetPlrFromChar(character)
	    if not player then return nil end
    	
        if not ESP.TeamColor then
        	return ESP:IsTeamMate(player) and Options.AllyColor.Value or Options.EnemyColor.Value
        end

        return GetTeamColor(player)
	end
end

-- Aimbot
local Aimbot = {} do
	local function isInCircle(point, center, radius)
		local rX = point.x - center.x
		local rY = point.y - center.y

		return (rX*rX) + (rY*rY) <= radius*radius
	end

	local circle = ESP.Draw('Circle', {
		Position = workspace.CurrentCamera.ViewportSize / 2,
		Transparency = 1,
		NumSides = 16,
		Thickness = 1,
		Color = Color3.new(1, 1, 1),
		Visible = false,
		ZIndex = 2,
	})

	local outline = ESP.Draw('Circle', {
		Position = workspace.CurrentCamera.ViewportSize / 2,
		Transparency = 1,
		NumSides = 16,
		Thickness = 3,
		Color = Color3.new(0, 0, 0),
		Visible = false
	})

	function Aimbot.UpdateCircle(value)
		if type(value) == 'number' then outline.Radius = value; circle.Radius = value end
		if type(value) == 'boolean' then outline.Visible = value; circle.Visible = value end
		if typeof(value) == 'Color3' then circle.Color = value end
	end

	Aimbot.PartNames = {}

	local payload = require(game.ReplicatedStorage:findFirstChild('CharacterPayload', true))
	local scrambled = getupvalue(getconnections(workspace.Characters.ChildAdded)[1].Function, 6)

	table.sort(payload, function(p0, p1) return p0 < p1 end)

	for i, name in next, payload do
		Aimbot.PartNames[name] = scrambled[i]
	end


	function Aimbot.solveTime(proj_pos, proj_speed, target, gravity)
	    local diff = target - proj_pos;
	    local diffXZ = Vector3.new(diff.x, 0, diff.z);
	    local groundDist = diffXZ.magnitude;

	    local speed2 = proj_speed * proj_speed;
	    local speed4 = speed2 * speed2;

	    local y = diff.y;
	    local x = groundDist;

	    local gx = gravity * x;

	    local root = speed4 - gravity * (gravity * x * x + 2 * y * speed2);

	    if (root < 0) then return nil end

	    root = math.sqrt(root);

	    local sol = math.atan2(speed2 - root, gx);
	    local s0 = diffXZ.Unit * math.cos(sol) * proj_speed + Vector3.new(0, 1, 0) * math.sin(sol) * proj_speed;
	    local t = x / (math.cos(sol) * proj_speed);

	    return s0, t;
	end

	function Aimbot.VelocityPrediction(startpos, endpos, vel, speed) -- Kinematics is fun
    	return endpos + (vel * ((endpos-startpos).Magnitude/speed))
	end

	function Aimbot.GetAimBone()
		local choice = Options.HitBone.Value
		local bones = { 'Head', 'Torso' }
		local namesMap = { Torso = 'Abdomen' }

		if choice == 'Random' then
			choice = bones[math.random(#bones)]
		end

		return Aimbot.PartNames[namesMap[choice] or choice]
	end

	table.insert(ESP.Objects, { 
		Update = function() 
			outline.Position = workspace.CurrentCamera.ViewportSize / 2 
			circle.Position = workspace.CurrentCamera.ViewportSize / 2 
		end
	})

	services.RunService.Heartbeat:Connect(function(dt)
		local center = workspace.CurrentCamera.ViewportSize / 2

		local clientCharacter = GetCharacter(client)
		local clientTeam = GetTeam(client)

		if not clientCharacter then 
			return 
		end

		local Choices = {}
		for _, plr in next, services.Players:GetPlayers() do
			if plr == client then continue end

			local character = GetCharacter(plr)
			local hitbox = character and character:findFirstChild('Hitbox')
			local bone = hitbox and hitbox:findFirstChild(Aimbot.PartNames.Head)

			local health = character and character:findFirstChild'Health'
			local shield = health and health:findFirstChild'Shield'

			if character and (not ESP:IsTeamMate(plr)) and bone and (not shield) then
				local pos, vis = workspace.CurrentCamera:WorldToViewportPoint(bone.Position)
				if not vis then
					continue
				end

				local screenPos = Vector2.new(pos.X, pos.Y)
				if (Toggles.FOVCircle and Toggles.FOVCircle.Value) then 
					if (not isInCircle(screenPos, center, circle.Radius)) then
						continue
					end
				end

				if Toggles.VisibleCheck.Value then
					local origin = workspace.CurrentCamera.CFrame.p;
					local point = bone.CFrame.p

					local ray = Ray.new(origin, point - origin)
					local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, { workspace.CurrentCamera, workspace.Effects, workspace.Gameplay, workspace.Projectiles })

					if hit and (not hit:IsDescendantOf(character)) then
						continue
					end
				end

				local distance = math.floor((screenPos - center).magnitude)
				table.insert(Choices, {
					Player = plr,
					Distance = distance,
					Character = character,
				})
			end
		end

		table.sort(Choices, function(a, b)
			return a.Distance < b.Distance
		end)

		local choice = Choices[1]
		if choice then
			local plr = choice.Player;

			Aimbot.target = plr;
			if Toggles.HighlightTarget.Value then
				ESP.Highlighted = choice.Character
			end
		else
			Aimbot.target = nil;
			ESP.Highlighted = nil
		end
	end)
end

-- ESP
do
	local HighlightStore = {}
	local function CreateChams(player, character)
		local cleaner = broom()

		local highlight = UI:Create('Highlight', {
			Enabled = false,
			Adornee = character,
			Parent = game.CoreGui,
		})

		cleaner:give(character:GetPropertyChangedSignal('Parent'):Connect(function()
			if not character:IsDescendantOf(workspace) then
				cleaner:clean()
			end
		end))

		cleaner:give(highlight)
		cleaner:give(function() HighlightStore[player] = nil end)

		HighlightStore[player] = highlight
	end

	local function onCharacterAdded(character)
		local player = GetPlayerFromCharacter(character)

		if player == client then return end
		if not player then return end

		ESP:Add(character, { Name = player.Name, Player = player, PrimaryPart = character:WaitForChild('Root') })
		CreateChams(player, character)

		if UI.CharacterAddedCallback then
			UI.CharacterAddedCallback(player, character)
		end
	end

	for _, character in next, workspace:WaitForChild('Characters'):GetChildren() do
		task.defer(onCharacterAdded, character)
	end

	workspace:WaitForChild('Characters').ChildAdded:Connect(function(character) 
		task.defer(onCharacterAdded, character) 
	end)

	services.RunService.Heartbeat:Connect(function()
		for Player, Highlight in next, HighlightStore do

			local DoesDraw = Toggles.ChamsEnabled.Value
			local IsTeamMate = ESP:IsTeamMate(Player)

			if not Toggles.ChamsShowTeams.Value and DoesDraw then
				DoesDraw = (not IsTeamMate)
			end

			local color 		= Toggles.ChamsTeamColors.Value and GetTeamColor(Player) or (IsTeamMate and Options.ChamsAllyFill.Value    or Options.ChamsEnemyFill.Value)
			local outlineColor  = Toggles.ChamsTeamColors.Value and GetTeamColor(Player) or (IsTeamMate and Options.ChamsAllyOutline.Value or Options.ChamsEnemyOutline.Value)

			local transparency = Options.ChamsTransparency.Value
			local outlineTransparency = Options.ChamsOutlineTransparency.Value

			if Player == Aimbot.target and Toggles.HighlightTarget.Value then
				color = ESP.HighlightColorDark
				outlineColor = ESP.HighlightColor
			end

			Highlight.FillColor 	= color
			Highlight.OutlineColor 	= outlineColor

			Highlight.FillTransparency 		= transparency
			Highlight.OutlineTransparency   = outlineTransparency
			Highlight.DepthMode 			= Options.ChamsMode.Value == 'Always show' and Enum.HighlightDepthMode.AlwaysOnTop or Enum.HighlightDepthMode.Occluded
			Highlight.Enabled 				= DoesDraw
		end
	end)
end
 

-- Anti cheat bypass
local CreateProxy, sigged do
	local FireServer, random = clonefunction(Instance.new('RemoteEvent').FireServer), clonefunction(getrenv().math.random)

	for _, fn in next, getgc() do
		if type(fn) == 'function' then 
			getfenv(v) -- bai bai lil luau optimization
		end
	end

	sigged = {}
	replaceclosure(getrenv().math.random, function(...)
		if select('#', ...) == 0 then return random(...) end
		if checkcaller() then return random(...) end

		local min = select(1, ...)
		local max = select(2, ...)

		if type(min) == 'number' and (min == 5 or min == 7) then 
			if type(max) ~= 'number' then
				syn_context_set(7) UI:Notify('Detected anticheat flagging mechanism!') syn_context_set(2)
				sigged[getinfo(3).func] = true -- sig that poop
			end
		end

		return random(...)
	end)

	local namecall
	namecall = hookmetamethod(game, '__namecall', function(self, ...)
		local args = { ... }
		local mthd = getnamecallmethod()

		if self.ClassName == 'RemoteEvent' and mthd == 'FireServer' then

			local level = 3
			local block = false
			while debug.validlevel(level) do
				if sigged[debug.getinfo(level).func] then block = true break end
				level = level + 1 
			end

			if block then
				syn_context_set(7) UI:Notify(string.format('Blocked anticheat report (direct) (%s)', tostring(args[2]))) syn_context_set(2)
				return Instance.new('BindableEvent').Event:Wait()
			end
		end

		return namecall(self, ...)
	end)

	replaceclosure(Instance.new('RemoteEvent').FireServer, function(...)
		local self = select(1, ...)
		if typeof(self) ~= 'Instance' then return FireServer(...) end
		if self.ClassName ~= 'RemoteEvent' then return FireServer(...) end

		local level = 3
		local block = false
		while debug.validlevel(level) do
			if sigged[debug.getinfo(level).func] then block = true break end
			level = level + 1 
		end

		if block then
			syn_context_set(7) UI:Notify(string.format('Blocked anticheat report (indirect) (%s)', tostring(args[2]))) syn_context_set(2)
			return Instance.new('BindableEvent').Event:Wait()
		end

		return FireServer(...)
	end)

	function CreateProxy(f)
		return function(...) -- since we can only have 1 upvalue :|
			return f(...)
		end
	end
end

local Storage = {}
do
	Storage.MarkedProjectiles = {}
	Storage.Random = Random.new()

	local ProjecitleConfigs = getupvalue(Tortoiseshell.Projectiles.InitProjectile, 1)

	-- backup functions
	local Fire, CastGeometryAndEnemies, Wait 

	local function FireProxy(self, event, ...)
		local args = { ... }

		if event == 'Item_Paintball' and args[1] == 'Shoot' then
			if Toggles.SilentAim.Value and Storage.Random:NextNumber(1, 100) <= Options.HitChance.Value and Options.SilentAimBind:GetState() then
				local stack = debug.getstack(3)
				local weaponData = debug.getupvalue(3, 4)

				local target = Aimbot.target;
				if target then
					local character = GetCharacter(target)
					local hitbox = character and character:findFirstChild('Hitbox')
					local root = character and character:findFirstChild('Root')
					local bone = hitbox and hitbox:findFirstChild(Aimbot.GetAimBone()) --Options.HitBone.Value)

					if bone then
						local origin = args[3]
						local template = weaponData.Projectile.Template
								
						local speed = ProjecitleConfigs[template].Speed
						local gravity = ProjecitleConfigs[template].Gravity

					--	syn_context_set(7) UI:Notify(string.format('Speed: %*', speed)) syn_context_set(2)

						local pos = Aimbot.VelocityPrediction(workspace.CurrentCamera.CFrame.p, bone.Position, root.Velocity, speed)
						local dir, travelTime = Aimbot.solveTime(origin, speed, pos, math.abs(gravity))

						if dir then
							local projectiles = stack[4]
							for i = 1, #projectiles do
								projectiles[i][1] = dir.unit * 60
							end
							setstack(3, 4, projectiles)
							args[4] = projectiles

							for _, p in next, projectiles do
								Storage.MarkedProjectiles[p[2]] = {
									Bone = bone,
									Character = character,
								}
							end

							if Toggles.DoubleTap.Value and (not UI.Block) then
								UI.Block = true
								local s, err = pcall(debug.info(3, 'f'))
								if not s then
									UI:Notify('DT ERR: ' .. tostring(err), 3)
								end
								UI.Block = false
							end
						end
					end
				end
			end

			local nups = getinfo(3).nups
			local recoilFunctionNames = { Recoil = true, WeaponRecoil = true, CameraRecoil = true }

			for i = 1, nups do
				local upv = getupvalue(3, i)
				if type(upv) == 'function' and recoilFunctionNames[getinfo(upv).name] then
					setupvalue(3, i, function(...)
						if Toggles.NoRecoil.Value then return end
						return upv(...)
					end)
				end
			end
		end

		if event == 'Character' and args[1] == 'State' then 
			if args[2] == 'Look' and Toggles.AntiAim.Value then
				args[3] = '-nan(ind)'
				Fire(self, "Character", "State", "Stance", "Prone")
			end
		end

		if args[1] == '__Hit' then
			local data = Storage.MarkedProjectiles[args[2]]
			if data then
				return Fire(self, "Projectiles", "__Hit", args[2], data.Bone.Position, data.Bone, Vector3.fromNormalId(Enum.NormalId.Top), data.Character)
			end
		end

		if sigged[debug.getinfo(2).func] then
			syn_context_set(7) UI:Notify(string.format('Blocked anticheat report (module) (%s)', tostring(args[1]))) syn_context_set(2)
			return Instance.new('BindableEvent').Event:Wait()
		end

		return Fire(self, event, unpack(args))
	end
	
	local function CastGeometryAndEnemiesProxy(self, ...)
		local args = { ... }

		local owner = args[3]
		if owner == client then
			local list = workspace.Characters:GetChildren()
			local characters = {}

			for _, character in next, list do
				local hitbox = character:findFirstChild'Hitbox'
				if not hitbox then continue end

				local player = Tortoiseshell.Characters:GetPlayerFromCharacter(character)
				if not player then continue end
				if player == client then continue end

				if (not Tortoiseshell.Teams:ArePlayersFriendly(client, player)) then
					table.insert(characters, hitbox)
				end
			end

			args[4] = { GeometryEnemyCache = characters }
		end

		return CastGeometryAndEnemies(self, unpack(args))
	end

	local function WaitProxy(self, ...)
		local args = { ... }

		if table.find(getconstants(3), 'FireRate') and Toggles.FireRate.Value then
			local num = 60 / args[1]
			args[1] = 60 / (num * Options.FireRateMult.Value)
		end

		return Wait(self, unpack(args))
	end

	Fire = hookfunction(Tortoiseshell.Network.Fire, CreateProxy(FireProxy))
	Wait = hookfunction(Tortoiseshell.Timer.Wait, CreateProxy(WaitProxy))
	CastGeometryAndEnemies = hookfunction(Tortoiseshell.Raycast.CastGeometryAndEnemies, CreateProxy(CastGeometryAndEnemiesProxy))
end

-- Auto shoot
do
	local autoShootStep = 0
	local lastShot = tick()

	services.RunService.Heartbeat:Connect(function(dt)
		autoShootStep = autoShootStep + dt
		if autoShootStep > 1 / 60 and Toggles.AutoShoot.Value then
			local target = Aimbot.target;
			if not target then return end

			local character = GetCharacter(target)
			local hitbox = character and character:findFirstChild('Hitbox')
			local bone = hitbox and hitbox:findFirstChild(Aimbot.PartNames.Head)

			local myCharacter = GetCharacter(client)
			local backpack = myCharacter and myCharacter:findFirstChild('Backpack')
			local equipped = backpack and backpack:findFirstChild('Equipped')

			if not equipped then return end

			local weapon = equipped.Value 
			local melee = backpack.Melee.Value

			if bone and weapon and melee and (weapon.Name ~= melee.Name) then
				local camera = workspace.CurrentCamera.CFrame;

				local origin = camera.p
				local point = bone.Position;
				local direction = point - origin

				local canShootPlayer = {}
				local ignoreList = { workspace.CurrentCamera }

				local hitCount = 0;
				local ray = Ray.new(origin, direction)

				if Toggles.Wallbang.Value then
					for i = 1, 5 do
						local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)

						if hit then
							if hit:IsDescendantOf(character) then 
								break
							end

							hitCount = hitCount + 1
							table.insert(ignoreList, hit)
						end
					end
				else
					local hit, pos = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
					if not hit:IsDescendantOf(character) then
						return
					end
				end

				if hitCount < 2 then
					if tick() - lastShot > Options.AutoShootDelay.Value then
						lastShot = tick()
						Tortoiseshell.Input:AutomateBegan'Shoot'
						Tortoiseshell.Input:AutomateEnded'Shoot'
					end
				end
			end
		end
	end)
end

-- Local stuff
do
	local newindex
	newindex = hookmetamethod(game, '__newindex', function(self, key, value)
		if self == workspace.CurrentCamera and key == 'CFrame' and Toggles.ThirdPerson.Value then
			value *= CFrame.new(Options.XOffset.Value, Options.YOffset.Value, Options.ZOffset.Value)
		end
		return newindex(self, key, value)
	end)
end

-- Movement
do
	services.RunService.RenderStepped:Connect(function(dt)
		local character = GetCharacter(client)
		local root = character and character:findFirstChild('Root')

		local health = character and character:findFirstChild('Health')

		if Toggles.Fly.Value and root and health and health.Value > 0 and Options.FlyBind:GetState() then
			local camCF = workspace.CurrentCamera.CFrame
			local speed = Options.FlySpeed.Value

			local force = Vector3.new()

			if services.UserInputService:IsKeyDown(Enum.KeyCode.W) then force = force + (camCF.lookVector   * speed) end
			if services.UserInputService:IsKeyDown(Enum.KeyCode.S) then force = force + (-camCF.lookVector  * speed) end
			if services.UserInputService:IsKeyDown(Enum.KeyCode.A) then force = force + (-camCF.rightVector * speed) end
			if services.UserInputService:IsKeyDown(Enum.KeyCode.D) then force = force + (camCF.rightVector  * speed) end

			if services.UserInputService:IsKeyDown(Enum.KeyCode.Space) then force = force + (camCF.upVector  * speed) end
			if services.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then force = force + (-camCF.upVector  * speed) end

			if not Storage.FlyCF then
				Storage.FlyCF = CFrame.new(root.CFrame.p)
			end

			Storage.FlyCF = Storage.FlyCF * CFrame.new(force)

			root.CFrame = CFrame.lookAt(Storage.FlyCF.p, camCF.p + (camCF.lookVector * 10000))
			root.Velocity = Vector3.new()
		else
			Storage.FlyCF = nil
		end
	end)
end

-- Hit logs
do
	local hitLogBroom = broom()

	function UI.CharacterAddedCallback(player, character)
		if player == client then return end
		hitLogBroom[player] = nil

		local health = character:WaitForChild('Health', 10)
		local maxHealth = health and health:WaitForChild('MaxHealth', 10)

		local tags = health:findFirstChild('DamageTags')
		
		local cleaner = broom()

		local function initTagsWatch(tags)
			--chalk.print('Initializing tag watch for', tags:GetFullName())

			local function onHitTagCreated(tag)
				--chalk.print('Tag created!', tag:GetFullName())
				if Toggles.HitLogs.Value then 
					UI:Notify(string.format('Hit %s for %d damage', player.Name, tag.Value))
				--	UI:Notify(string.format('Dealt %d damage to player %q!\nHealth: %d/%d', tag.Value, player.Name, health.Value, maxHealth.Value), 3)
				end

				local old = tag.Value
				cleaner:give(tag:GetPropertyChangedSignal('Value'):Connect(function()
				--	chalk.print('Tag updated!', tag:GetFullName(), 'Old value', old, 'New value', tag.Value)

					if tag.Value == old then return end

					local damage = tag.Value - old
					old = tag.Value

					if Toggles.HitLogs.Value then
						UI:Notify(string.format('Hit %s for %d damage', player.Name, damage))
					--	UI:Notify(string.format('Dealt %d damage to player %q!\nHealth: %d/%d', damage, player.Name, health.Value, health.MaxHealth.Value), 3)
					end
				end))
			end

			for _, obj in next, tags:GetChildren() do
				if obj.Name == client.Name then
					task.defer(onHitTagCreated, obj)
				end
			end

			cleaner:give(tags.ChildAdded:Connect(function(tag)
				if tag.Name == client.Name then
					task.defer(onHitTagCreated, tag)
				end
			end))
		end

		cleaner:give(health.ChildAdded:Connect(function(tags)
			initTagsWatch(tags)
		end))

		cleaner:give(character:GetPropertyChangedSignal('Parent'):Connect(function()
			if not character.Parent then
				cleaner:clean()
			end
		end))

		if tags then
			initTagsWatch(tags)
		end

		hitLogBroom[player] = cleaner
	end

	for _, plr in next, services.Players:GetPlayers() do
		local character = GetCharacter(plr)
		if character then
			task.spawn(UI.CharacterAddedCallback, plr, character)
		end
	end
end

-- Melee aura
local WarpToTarget do
	local meleeAuraStep = 0

	services.RunService.Heartbeat:Connect(function(dt)
		meleeAuraStep = meleeAuraStep + dt
		if meleeAuraStep > 1/60 and Toggles.MeleeAura.Value then
			meleeAuraStep = 0

			local cameraCf = workspace.CurrentCamera.CFrame
			local character = GetCharacter(client)
			local backpack = character and character:findFirstChild('Backpack');
			local equipped = backpack and backpack:findFirstChild'Equipped' 

			if not equipped then return end

			local weapon = equipped.Value
			if not weapon or not weapon:findFirstChild'Config' then return end

			local config = require(weapon.Config)
			if type(config) ~= 'table' or config.Controller ~= 'Melee' then return end

			local range = Options.MeleeAuraDistance.Value

			local targets = {}
			for _, plr in next, services.Players:GetPlayers() do
				if plr == client then continue end
				if ESP:IsTeamMate(plr) then continue end

				local character = GetCharacter(plr)
				local root = character and character:findFirstChild('Root')
				local hitbox = character and character:findFirstChild('Hitbox')

				if not root or not hitbox then continue end

				local distance = math.floor((root.Position - cameraCf.p).magnitude)
				if distance > range then continue end

				table.insert(targets, {
					Player = plr,
					Character = character,
					Hitbox = hitbox,
					Distance = distance,
				})
			end

			table.sort(targets, function(a, b) return a.Distance < b.Distance end)

			local found = targets[1]
			if found then
				local part = found.Hitbox:findFirstChild(Aimbot.PartNames.Head)
				if not part then
					return
				end

				local position = part.Position;

				Tortoiseshell.Network:Fire('Item_Melee', 'StabBegin', weapon)
				Tortoiseshell.Network:Fire('Item_Melee', 'Stab', weapon, part, position, CFrame.lookAt(cameraCf.p, position).lookVector * config.Melee.Range)
			end
		end
	end)

	function WarpToTarget()
		local plr = Aimbot.target;
		local character = GetCharacter(plr)
		local root = character and character:findFirstChild('Root')

		if not root then return end
		
		local localCharacter = GetCharacter(client)
		local localRoot = localCharacter and localCharacter:findFirstChild('Root')

		if not localRoot then return end

		localRoot.CFrame = CFrame.lookAt((root.CFrame * CFrame.new(0, 0, 5)).p, root.CFrame.p) 
	end
end

-- Hit sounds
local UpdateHitSounds do
	local mainGui = client:WaitForChild('PlayerGui'):WaitForChild('MainGui');
	local hitmarker = mainGui:WaitForChild('HitmarkerScript')

	local headshotSound	= hitmarker:WaitForChild('HeadshotSound')
	local hitmarkerSound = hitmarker:WaitForChild('HitmarkerSound')
	local killSound = hitmarker:WaitForChild('KillSound')

	local soundMap = {
		Rust  = 'rbxassetid://5043539486',
		Skeet = 'rbxassetid://5447626464',
		['Boom Headshot'] = 'rbxassetid://7551341361',
	}

	local soundList = {}
	for _, sound in next, soundMap do
		table.insert(soundList, sound)
	end

	task.spawn(function()
		services.ContentProvider:PreloadAsync(soundList)
	end)

	Storage.HeadSound = UI:Create('Sound', {
		SoundId = '',
		Volume = 1,
		Parent = services.CoreGui,
	})

	Storage.HitSound = UI:Create('Sound', {
		SoundId = '',
		Volume = 1,
		Parent = services.CoreGui,
	})

	Storage.KillSound = UI:Create('Sound', {
		SoundId = '',
		Volume = 1,
		Parent = services.CoreGui,
	})

	Tortoiseshell.UI.Events.Hitmarker.Event:Connect(function(hitPart)
		headshotSound.Volume  = Options.HeadSound.Value == 'Default' and 1 or 0
		hitmarkerSound.Volume = Options.HitSound.Value == 'Default' and 1 or 0

		if hitPart.Name == Aimbot.PartNames.Head and Options.HeadSound.Value ~= 'Default' then 
			Storage.HeadSound:Play()
		elseif Options.HitSound.Value ~= 'Default' then
			Storage.HitSound:Play()
		end
	end)

	local KillSayMsgs = {
		'get dumped on', 'ur stinky {victim}', 
		'imagine dying', 'L + ratio + you fell off', 
		'potato pc', 'i have a better gaming chair than you :)', 
		'i have thigh highs and you dont :P',
	}

	Tortoiseshell.Damage.CharacterKilled:Connect(function(...)
		local args = { ... }
		local killer = args[3]

		if killer == client then
		--	UI:Notify('Someone died because of us.')				
			killSound.Volume = Options.KillSound.Value == 'Default' and 1 or 0

			if Options.KillSound.Value ~= 'Default' then
				Storage.KillSound:Play()
			end

			if Toggles.KillSay.Value then
				UI:Notify('Killsay go brrr')
				local victim = GetPlayerFromCharacter(args[1])
				local msg = KillSayMsgs[math.random(#KillSayMsgs)]

				msg = msg:gsub("{victim}", victim.DisplayName)
				services.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, 'All')
			end
		end
	end)

	function UpdateHitSounds()
		Storage.HitSound.SoundId = soundMap[Options.HitSound.Value] or soundMap.Rust
		Storage.HeadSound.SoundId = soundMap[Options.HeadSound.Value] or soundMap.Rust
		Storage.KillSound.SoundId = soundMap[Options.KillSound.Value] or soundMap.Rust
	end
end

-- Grenade warp
do
	workspace.Throwables.ChildAdded:connect(function(obj)
		if obj.Name == 'Frag' and Toggles.GrenadeWarp.Value and Aimbot.target then
			local root = obj.PrimaryPart
			while not root do
				root = obj.PrimaryPart
				services.RunService.Stepped:Wait()
			end

			if (not isnetworkowner(root)) then 
				return -- UI:Notify('not net owner')
			end

			local target = Aimbot.target;
			local character = GetCharacter(target)

			local part = character and character:findFirstChild('Root')
			if not part then
				return -- UI:Notify'No part'
			end

			while obj.Parent do
				root.CFrame = part.CFrame * CFrame.new(0, 0.5, 0)
				services.RunService.Heartbeat:wait()
			end
		end
	end)
end

local Window = UI:CreateWindow('misc projects - bad business')

local Tabs = {}
local Groups = {}

Tabs.Combat = Window:AddTab('Combat')
Tabs.Visuals = Window:AddTab('Visuals')
Tabs.Character = Window:AddTab('Character')
Tabs.Other = Window:AddTab('Miscellaneous')
Tabs.Interface = Window:AddTab('UI Settings')

Groups.SilentAim = Tabs.Combat:AddLeftGroupbox('Silent aim')
Groups.AutoShoot = Tabs.Combat:AddLeftGroupbox('Auto shoot')
Groups.Weapons = Tabs.Combat:AddLeftGroupbox('Weapon modifications')

Groups.MiscWeaponMods = Tabs.Combat:AddLeftTabbox()
Groups.Melee = Groups.MiscWeaponMods:AddTab('Melee')
Groups.Grenades = Groups.MiscWeaponMods:AddTab('Grenade')

Groups.AimbotSettings = Tabs.Combat:AddRightGroupbox('Aim settings')

Groups.PlayerVisuals = Tabs.Visuals:AddLeftGroupbox('ESP')
Groups.PlayerChams = Tabs.Visuals:AddRightGroupbox('Chams')
-- Groups.LocalCharacter = Tabs.Visuals:AddRightGroupbox('Local character')

Groups.Movement = Tabs.Character:AddLeftGroupbox('Movement')
Groups.ThirdPerson = Tabs.Character:AddLeftGroupbox('Third person')
Groups.AntiAim = Tabs.Character:AddRightGroupbox('Aim settings')

-- Groups.ModelVisuals = Tabs.Character:AddLeftGroupbox('Character visuals')

Groups.ServerHop = Tabs.Other:AddLeftGroupbox('Server hop')
Groups.Other = Tabs.Other:AddLeftGroupbox('Miscellaneous')
Groups.Sounds = Tabs.Other:AddLeftGroupbox('Custom sounds')

-- Silent aim 
Groups.SilentAim:AddToggle('SilentAim',  { Text = 'Silent aim' }):AddKeyPicker('SilentAimBind', { Default = 'MB2', Mode = 'Always', Text = 'Silent aim' })
Groups.SilentAim:AddToggle('Wallbang',   { Text = 'Wallbang', Tooltip = 'Allows you to penetrate walls. Only works at close range.' })
Groups.SilentAim:AddToggle('DoubleTap',  { Text = 'Double tap', Tooltip = 'Shoots 2 bullets per shot' })

Groups.AutoShoot:AddToggle('AutoShoot', { Text = 'Auto shoot' })
Groups.AutoShoot:AddSlider('AutoShootDelay', { Text = 'Auto shoot delay', Min = 0, Max = 1, Rounding = 2, Default = 0.3 })

Groups.AimbotSettings:AddToggle('VisibleCheck', { Text = 'Visible check' })
Groups.AimbotSettings:AddDivider()
Groups.AimbotSettings:AddToggle('FOVCircle', { Text = 'Show circle' }):AddColorPicker('FOVColor', { Default = Color3.new(1, 1, 1) })
Groups.AimbotSettings:AddSlider('FOVRadius', { Text = 'Circle radius', Min = 0, Max = 500, Default = 0, Rounding = 0 })
Groups.AimbotSettings:AddDivider()
Groups.AimbotSettings:AddSlider('HitChance', { Text = 'Hit chance %', Min = 0, Max = 100, Default = 100, Rounding = 1 })
Groups.AimbotSettings:AddDropdown('HitBone', { Text = 'Hit part', Default = 1, Values = { 'Head', 'Torso', 'Random' } })

Groups.Melee:AddToggle('MeleeAura', { Text = 'Melee aura' })
Groups.Melee:AddSlider('MeleeAuraDistance', { Text = 'Melee aura range', Min = 3, Max = 22, Default = 3, Rounding = 0 })

Groups.Grenades:AddToggle('GrenadeWarp', { Text = 'Grenade warp' })

-- Weapons
Groups.Weapons:AddToggle('NoRecoil', { Text = 'No recoil' })
Groups.Weapons:AddToggle('NoSpread', { Text = 'No spread' })

Groups.Weapons:AddToggle('FireRate', 	 { Text = 'Fire rate' })
Groups.Weapons:AddSlider('FireRateMult', { Text = 'Fire rate multiplier', Min = 0.1, Max = 3, Default = 1, Rounding = 1 })

Groups.Sounds:AddDropdown('HitSound',  { Text = 'Hit sound',	  Default = 1, Values = { 'Default', 'Rust', 'Skeet', 'Boom Headshot' } })
Groups.Sounds:AddDropdown('HeadSound', { Text = 'Headshot sound', Default = 1, Values = { 'Default', 'Rust', 'Skeet', 'Boom Headshot' } })
Groups.Sounds:AddDropdown('KillSound', { Text = 'Kill sound',	  Default = 1, Values = { 'Default', 'Rust', 'Skeet', 'Boom Headshot' } })

Groups.Other:AddToggle('KillSay', { Text = 'Kill say' })
Groups.Other:AddToggle('HitLogs', { Text = 'Show hit logs' })

-- Character
Groups.Movement:AddToggle('Fly', { Text = 'Fly' }):AddKeyPicker('FlyBind', { Text = 'Fly', Default = 'F3' })
Groups.Movement:AddSlider('FlySpeed', { Text = 'Fly speed', Min = 0.1, Max = 2, Rounding = 1, Default = 0.1 })

Groups.ThirdPerson:AddToggle('ThirdPerson', { Text = 'Enabled' })
Groups.ThirdPerson:AddSlider('XOffset', { Text = 'X offset', Min = 0, Max = 10, Default = 0, Rounding = 1 })
Groups.ThirdPerson:AddSlider('YOffset', { Text = 'Y offset', Min = 0, Max = 10, Default = 0, Rounding = 1 })
Groups.ThirdPerson:AddSlider('ZOffset', { Text = 'Z offset', Min = 0, Max = 10, Default = 0, Rounding = 1 })

Groups.AntiAim:AddToggle('AntiAim', { Text = 'Anti aim', Tooltip = 'Hides your upper body from other players.' })

Groups.ServerHop:AddToggle('AutoHopKick', { Text = 'Auto server-hop on kick' })
Groups.ServerHop:AddButton('Server hop',  Utilities.ServerHop)

-- ESP
Groups.PlayerVisuals:AddToggle('ESPEnabled',     { Text = 'Enabled' })

Groups.PlayerVisuals:AddToggle('ESPShowNames',   { Text = 'Show names', Default = true })
Groups.PlayerVisuals:AddToggle('ESPShowBoxes',   { Text = 'Show boxes' })
Groups.PlayerVisuals:AddToggle('ESPShowTracers', { Text = 'Show tracers' })

Groups.PlayerVisuals:AddDivider()

Groups.PlayerVisuals:AddToggle('ESPTeamColors', { Text = 'Use team colors' })
Groups.PlayerVisuals:AddToggle('ESPShowTeams', { Text = 'Show teammates' })
Groups.PlayerVisuals:AddToggle('ESPFaceCamera', { Text = 'Face camera' })

Groups.PlayerVisuals:AddDivider()

Groups.PlayerVisuals:AddLabel('Enemy color'):AddColorPicker('EnemyColor', 			{ Default = Color3.new(1, 0, 0), Title = 'Enemy color' })
Groups.PlayerVisuals:AddLabel('Ally color'):AddColorPicker('AllyColor',  			{ Default = Color3.new(0, 1, 0), Title = 'Teammate color' });
Groups.PlayerVisuals:AddToggle('HighlightTarget', { Text = 'Highlight target' }):AddColorPicker('HighlightColor', 	{ Default = Color3.new(1, 1, 1), Title = 'Highlight color' })

Groups.PlayerVisuals:AddDivider()

Groups.PlayerVisuals:AddDropdown('ESPFont',    { Text = 'ESP Font',    Default = 1,  Values = { 'UI', 'Monospace', 'Plex', 'System' } })
Groups.PlayerVisuals:AddSlider('ESPFontSize',  { Text = 'Font Size',   Min = 8, Max = 22, Default = 19, Rounding = 0 })

Groups.PlayerChams:AddToggle('ChamsEnabled',  	{ Text = 'Enabled' })
Groups.PlayerChams:AddToggle('ChamsTeamColors', { Text = 'Use team colors' })
Groups.PlayerChams:AddToggle('ChamsShowTeams',  { Text = 'Show teammates' })

Groups.PlayerChams:AddDivider()

Groups.PlayerChams:AddSlider('ChamsTransparency', { Text = 'Transparency', Min = 0, Max = 1, Default = 0, Rounding = 1 })
Groups.PlayerChams:AddSlider('ChamsOutlineTransparency', { Text = 'Outline transparency', Min = 0, Max = 1, Default = 0, Rounding = 1 })

Groups.PlayerChams:AddLabel('Enemy colors')
	:AddColorPicker('ChamsEnemyFill', 	  { Title = 'Enemy fill color',    Default = Color3.new(1, 0, 0) })
	:AddColorPicker('ChamsEnemyOutline',  { Title = 'Enemy outline color', Default = UI:GetDarkerColor(Color3.new(1, 0, 0)) })

Groups.PlayerChams:AddLabel('Ally colors')
	:AddColorPicker('ChamsAllyFill', 	 { Title = 'Ally fill color',    Default = Color3.new(0, 1, 0) })
	:AddColorPicker('ChamsAllyOutline',  { Title = 'Ally outline color', Default = UI:GetDarkerColor(Color3.new(0, 1, 0)) })

Groups.PlayerChams:AddDropdown('ChamsMode', { Text = 'Chams mode', Default = 1, Values = { 'Always show', 'Show when visible' } })

-- OnChanged bs

Toggles.FOVCircle:OnChanged(function() Aimbot.UpdateCircle(Toggles.FOVCircle.Value) end)
Options.FOVColor:OnChanged(function() Aimbot.UpdateCircle(Options.FOVColor.Value) end)
Options.FOVRadius:OnChanged(function() Aimbot.UpdateCircle(Options.FOVRadius.Value) end)

Options.HitSound:OnChanged(UpdateHitSounds)
Options.HeadSound:OnChanged(UpdateHitSounds)
Options.KillSound:OnChanged(UpdateHitSounds)

Toggles.ESPEnabled:OnChanged(function() ESP:Toggle(Toggles.ESPEnabled.Value) end)

Toggles.ESPShowNames:OnChanged(function() ESP.Names = Toggles.ESPShowNames.Value end)
Toggles.ESPShowBoxes:OnChanged(function() ESP.Boxes = Toggles.ESPShowBoxes.Value end)
Toggles.ESPShowTracers:OnChanged(function() ESP.Tracers = Toggles.ESPShowTracers.Value end)

Toggles.ESPTeamColors:OnChanged(function() ESP.TeamColor = Toggles.ESPTeamColors.Value end)
Toggles.ESPShowTeams:OnChanged(function() ESP.TeamMates = Toggles.ESPShowTeams.Value end)
Toggles.ESPFaceCamera:OnChanged(function() ESP.FaceCamera = Toggles.ESPFaceCamera.Value end)

Options.ESPFont:OnChanged(function() ESP.Font = Options.ESPFont.Value end)
Options.ESPFontSize:OnChanged(function() ESP.FontSize = Options.ESPFontSize.Value end)
Options.HighlightColor:OnChanged(function() ESP.HighlightColor = Options.HighlightColor.Value; ESP.HighlightColorDark = UI:GetDarkerColor(Options.HighlightColor.Value) end)

-- UI settings
do
	ThemeManager:ApplyToTab(Tabs.Interface)
	SaveManager:BuildConfigSection(Tabs.Interface)

	Groups.Menu  = Tabs.Interface:AddRightGroupbox('Menu options')
	Groups.Other = Tabs.Interface:AddRightGroupbox('Misc functions')

	Groups.Menu:AddToggle('KeybindMenu', { Text = 'Show keybinds menu', Default = true  })
	Groups.Menu:AddToggle('WatermarkVis', { Text = 'Show watermark', Default = true })

	Toggles.KeybindMenu:OnChanged(function()
		UI.KeybindFrame.Visible = Toggles.KeybindMenu.Value;
	end)

	Toggles.WatermarkVis:OnChanged(function()
		UI:SetWatermarkVisibility(Toggles.WatermarkVis.Value);
	end)

	Groups.Other:AddButton('Rejoin game', function()
		services.TeleportService:Teleport(game.PlaceId)
	end)

	Groups.Other:AddButton('Rejoin same server', function()
		services.TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
	end)
end

UI:SetWatermark(string.format('misc projects | bad business | debug mode: %s', tostring(DEBUG_MODE)))
UI:Notify('Welcome, ' .. username)
UI:Notify('Loaded misc projects for Bad Business!')
UI:Notify('Press "RightControl" to toggle the UI.')

SaveManager:LoadAutoloadConfig()
